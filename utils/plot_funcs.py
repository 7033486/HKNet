"""
This code is generated by Ridvan Salih KUZU @UNIROMA3
LAST EDITED:  03.04.2020
ABOUT SCRIPT:
It is a script for performance visualization functions.
"""

import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.metrics import auc

def plot_roc(fpr, tpr, figure_name="roc.png"):
    plt.switch_backend('Agg')

    roc_auc = auc(fpr, tpr)
    fig = plt.figure()
    lw = 2
    plt.plot(fpr, tpr, color='red',
             lw=lw, label='ROC curve (area = %0.8f)' % roc_auc)
    plt.plot([0, 1], [0, 1], color='blue', lw=lw, linestyle='--')
    plt.xlim([-0.01, 1.0])
    plt.ylim([0.0, 1.01])
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Receiver operating characteristic')
    plt.legend(loc="lower right")
    plt.grid(True)
    fig.savefig(figure_name, dpi=fig.dpi)


def plot_DET_with_EER(far, frr, far_optimum, frr_optimum, figure_name):
    """ Plots a DET curve with the most suitable operating point based on threshold values"""
    fig = plt.figure()
    lw = 2
    # Plot the DET curve based on the FAR and FRR values
    EER = float((far_optimum + frr_optimum) / 2)
    plt.plot([0, 1], [0, 1], color='blue', lw=lw, linestyle='--')
    plt.plot(far, frr, color='red', linewidth=lw, label='DET Curve (EER = %0.8f)' % EER)
    # Plot the optimum point on the DET Curve
    plt.plot(far_optimum, frr_optimum, "ko", label="Suitable Operating Point")

    plt.xlim([-0.01, 0.1])
    plt.ylim([-0.01, 0.1])
    plt.xlabel('False Acceptance Rate')
    plt.ylabel('False Rejection Rate')
    plt.title('Detection Error Tradeoff')
    plt.legend(loc="upper right")
    plt.grid(True)
    fig.savefig(figure_name, dpi=fig.dpi)


def plot_density(distances, labels, figure_name):
    fig = plt.figure()
    pos_index = np.where(labels == 1)
    neg_index = np.where(labels == 0)
    p1 = sns.distplot(distances[pos_index], kde=True, norm_hist=False, bins=50, color="r", label="Genuine")
    p1 = sns.distplot(distances[neg_index], kde=True, norm_hist=False, bins=50, color="b", label="Impostor")
    #plt.xlim(0, 1)
    locs, labels = plt.yticks()
    plt.yticks(locs, list(map(str, locs * 0.01)))
    plt.ylabel('Density Distribution [%]', fontsize=18)
    plt.xlabel('Similarity Distance', fontsize=18)
    fig.savefig(figure_name)
    
def plot_density_with_ratio(distances, labels, figure_name):
    fig = plt.figure()
    pos_index = np.where(labels == 1)
    neg_index = np.where(labels == 0)

    sns.distplot(distances[pos_index], kde=True, norm_hist=False, bins=50, color="r", label="Genuine")
    sns.distplot(distances[neg_index], kde=True, norm_hist=False, bins=50, color="b", label="Impostor")

    bins = np.linspace(distances.min(), distances.max(), 51)  # 50 个区间
    pos_hist, _ = np.histogram(distances[pos_index], bins=bins)
    neg_hist, _ = np.histogram(distances[neg_index], bins=bins)
    
    r = pos_hist / (neg_hist + 1e-8)
    d_values = (r - 1) / (r + 1)
    d_values[d_values < 0] = 0
    
    total_samples = len(labels)  
    genuine_ratio_global = pos_hist / total_samples  
    d_s_values = d_values * genuine_ratio_global
    d_s_mean = np.nanmean(d_s_values)  
    print(d_s_mean)
    
    
    d_mean = np.nanmean(d_values)  
    

    bin_centers = (bins[:-1] + bins[1:]) / 2
    plt.plot(bin_centers, d_values, color="orange", linestyle="--", linewidth=8, label="D(s)")

    #plt.axhline(y=d_mean, color="orange", linestyle="--", label=f"Mean d = {d_mean:.2f}")

    plt.ylabel('Density Distribution [%]', fontsize=18)
    plt.xlabel('Similarity Distance', fontsize=18)
    plt.legend(fontsize=12)
    fig.savefig(figure_name)

    return d_mean

    
def plot_density_withline(distances, labels, x_max, figure_name):
    line_width=2.5
    fig = plt.figure()
    pos_index = np.where(labels == 1)
    neg_index = np.where(labels == 0)
    p1 = sns.distplot(distances[pos_index], kde=True, norm_hist=False, bins=50, color="r")
    p1 = sns.distplot(distances[neg_index], kde=True, norm_hist=False, bins=50, color="b")
    locs, labels = plt.yticks()
    plt.yticks(locs, list(map(str, locs * 0.01)))
    plt.ylabel('Density Distribution [%]', fontsize=18)
    plt.xlabel('Similarity Distance', fontsize=18)
    if x_max is not None:
        plt.axvline(x=x_max, color='red', linestyle='--', linewidth=line_width, label='Threshold distance for successful verification')
        plt.legend()
        
    #plt.axvline(x=0, color='purple', linestyle='--', linewidth=line_width, label='Threshold distance for perfect match')
    #plt.legend()    
        
    plt.subplots_adjust(left=0.18, right=0.95, top=0.95, bottom=0.15)
    fig.savefig(figure_name)
